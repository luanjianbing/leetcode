#include <iostream>
#include <vector>
#include <sstream>

using namespace std;

class Solution {
private:
	static constexpr int SEG_COUNT = 4;

	vector<string> ans;
	vector<int> segments;

public:
	// dfs(segId, segStart)表示正从segStart开始搜索ip地址中的segid段
	void dfs(const string& s, int segId, int segStart) {
		// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
		if (segId == SEG_COUNT) {
			if (segStart == s.size()) {
				string ipAddr;
				for (int i = 0; i < SEG_COUNT; ++i) {
					ipAddr += to_string(segments[i]);
					if (i != SEG_COUNT - 1) {
						ipAddr += ".";
					}
				}
				ans.push_back(move(ipAddr));
			}
			return;	// 已经到了第四段但是还没到底
		}

		// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯
		if (segStart == s.size()) {
			return;
		}

		// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
		if (s[segStart] == '0') {
			segments[segId] = 0;
			dfs(s, segId + 1, segStart + 1);
		}

		// 一般情况，枚举每一种可能性并递归
		int addr = 0;
		for (int segEnd = segStart; segEnd < s.size(); ++segEnd) {
			addr = addr * 10 + (s[segEnd] - '0');
			if (addr > 0 && addr <= 0xFF) {
				segments[segId] = addr;
				dfs(s, segId + 1, segEnd + 1);
			}
			else {
				break;
			}
		}
	}

	vector<string> restoreIpAddresses(string s) {
		segments.resize(SEG_COUNT);
		dfs(s, 0, 0);
		return ans;
	}
};

int main() {
	string str = "25525511135";
	Solution s;
	vector<string> res = s.restoreIpAddresses(str);

	for (int i = 0; i < res.size(); ++i)
		cout << res[i] << endl;

	return 0;
}
